/////////////////////////////////////////////////
// This algorithm is closedly modeled after that
// found at CITE
/////////////////////////////////////////////////


intrinsic TransposeMatrixGroup(G::GrpMat) -> GrpMat
	{ Given a matrix group G, return the
		matrix group generated by the transpose
		of each generator. }

	Gt := sub<GL(2,BaseRing(G)) | [Transpose(g):g in Generators(G)]>;

	return Gt;
end intrinsic;


intrinsic CyclicSubspaces(m::RngIntElt) -> SetEnum[ModTupRng]
	{ Given a positive integer m,
		return the set of all cyclic
		submodules of order m. }
	M:=RSpace(Integers(m),2);

	return {sub<M|[i,j]>:i in Divisors(m),j in [0..m-1]|GCD(i,j) eq 1};
end intrinsic;


intrinsic GroupIsogenyDegree(H::GrpMat) -> SeqEnum[RngIntElt]
	{ Given mod m image H, return degrees of all
		closed points on X_0(m).
		This function is not called in main algorithm. }
	m:=#BaseRing(H);
	H:=sub<GL(2,Integers(m))|[Transpose(h):h in Generators(H)]>;

	return [#Orbit(H,v): v in CyclicSubspaces(m)];
end intrinsic;


intrinsic CoveringDegree(m::RngIntElt,n::RngIntElt) -> RngIntElt
	{ Given two positive integers m, n, where
		n is a divisor of m, return the degree
		of the natural map from X_0(m) to X_0(n). }

	assert(m mod n eq 0);

	if n eq 2 then
		return (1/3)*m*&*[Rationals()|(1 + 1/p):p in PrimeFactors(m)];
		end if;
	if m eq 2 then // n divides m so n = 1 or 2
		if n eq 1 then
			return 3;
		else
			return 1;
			end if;
	end if;

	a := m div n;
	// b := (n le 2 and m gt 2) select 1/2 else 1;
	
	return a*&*[Rationals()|(1 + 1/p):p in PrimeFactors(m)|n mod p ne 0];
end intrinsic;


intrinsic PrimitiveDegreesOfPointsForFixedm(G::GrpMat, m::RngIntElt, primitivepts::SeqEnum[Any]) -> SeqEnum[Tup]
	{ Given a mod m image G, a divisor m of the
		reduced level of E, and a list to which we
		add primitive points, return a set of tuples
		<a1, d1>,  ..., <an, dn>, such that each
		<ai, di> pair represents a degree di primitive point
		associated to a closed point on X_0(m). }

	if m eq 1 then
	// <1, 1> is always a primitive deg 1 point on X_0(1).
		Append(~primitivepts, <1, 1>);
		return primitivepts;
	end if;

	Gmodm := ChangeRing(G, Integers(m));
	Gt := TransposeMatrixGroup(Gmodm);

	C:=SetToIndexedSet(CyclicSubspaces(m));
	
	// for-loop through each cyclic subspace of order m.
	for v in C do
		degx := #Orbit(Gt,v);
		
		i := 1;

		while i le #Divisors(m) do
			// 1 is the first entry in the list of divisors so this while-loop
			// always checks the degree condition on X_0(1) first.
			if i eq 1 then
				ai := Divisors(m)[i]; // ai = 1
				degf1 := CoveringDegree(m, 1);

				// note degx1 = 1 since we have rational j-invariant.
				if degx eq degf1 then
						Append(~primitivepts, <ai, 1>);
						// degree condition met so continue to next v in C.
						i := #Divisors(m)+1;

				elif degx ne degf1 then
					// degree condition not met, continue to next divisor.
					i +:= 1;
				end if;
			end if;

			// i = #Divisors(m)+1 is used to break the while-loop
			// and continue to the next v in C.
			if i eq #Divisors(m)+1 then
				break;
			end if;

        	ai := Divisors(m)[i];
			degfi := CoveringDegree(m, ai);
			
			// K is the module Z/aiZ^{(2)},
			// consisting of all 2-tuples over Z/aiZ.
			K := RSpace(Integers(ai),2);
			HmodAi := ChangeRing(Gt, Integers(ai));
			
			// to compute the degree of the image xi on X_0(ai), we now need the
			// subspace of K generated by the generator of v (mod ai).
			L := sub<K|K!v.1>;
			
			degxi := #Orbit(HmodAi,L);

			// if the degree di of the image of the point on X_0(ai) is as large as possible:
			if degx eq degfi * degxi then
				Append(~primitivepts, <ai,degxi>); // ai is the smallest such divisor of m because Divisors(m) is ordered so that a1 <= a2 <=...
				i := #Divisors(m)+1;
            
            // if ai = m itself, then the point x is its own primitive point:
			elif i eq #Divisors(m) then
				Append(~primitivepts, <Divisors(m)[i],degx>);
				i := #Divisors(m)+1;

			elif i ne #Divisors(m) then
				// check the next largest divisor of m
				i +:= 1;

			end if;
		end while;
	end for;
	return primitivepts;
end intrinsic;


intrinsic PrimitiveDegreesOfPoints(G0::GrpMat) -> SetEnum[Tup]
    { Given a mod m0 image, where m0 denotes the reduced level of an elliptic curve E,
     return the list of primitive points of E. }

	primitiveptsset := {};
    m := Modulus(BaseRing(TransposeMatrixGroup(G0)));
    
	for a in Divisors(m) do
		primitivepts := [];
		for pair in PrimitiveDegreesOfPointsForFixedm(G0, a, primitivepts) do
			Include(~primitiveptsset, pair);
		end for;
	end for;
    return primitiveptsset;
end intrinsic;


intrinsic FilterByRiemannRoch(primitivepts::SeqEnum[Tup]) -> SeqEnum[Tup]
	{ Given multiset of elements of the form
		<a1, d1>,  ... , <an, dn>,
		return those such that di is
		greater than genus(X_0(ai))
		for some i. }

	A := AssociativeArray();

	function CachedGenus(m,A)
		if m notin Keys(A) then
			A[m] := Genus(Gamma0(m));
		end if;
		return A[m], A;
	end function;
	
	function RiemannRochFilter(points,A)
		list := {*Parent({<1,1>})|  *};
		nonisolated := [];
		possibleisolated := [];
		for x in primitivepts do
			a, deg := Explode(x);
			genusGamma0, A := CachedGenus(a,A);
			
			// append those P1-parametrized by
			// Riemann-Roch Theorem
			if deg ge genusGamma0 + 1 then
				Append(~nonisolated,x);
			else
				Append(~possibleisolated,x);
			end if;
		end for;
		return possibleisolated;
	end function;

	returnlist := RiemannRochFilter(primitivepts,A);

	return returnlist;
end intrinsic;


intrinsic CheckIsolatedGamma0(G0::GrpMat) -> List
{Checks if a given ell-adic image can produce isolated points on X0(ell^n)}

	function FilterOutByGenus0(possibleisolated, G)
		// Given a list of tuples <ai, di>, return those
		// for which the image of G mod ai does not
		// have genus equal to 0.
		S := {* *};

		for point in possibleisolated do
			ai, di := Explode(point);
			Gmodai := ChangeRing(G,Integers(ai));
			if GL2Genus(Gmodai) ne 0 then
				Include(~S, point);
			end if;
		end for;

		return S;
	end function;

    possibleisolated := PrimitiveDegreesOfPoints(G0);

	possibleisolated := SetToIndexedSet(possibleisolated);
	possibleisolated := IndexedSetToSequence(possibleisolated);
	possibleisolatedfilter1 := FilterByRiemannRoch(possibleisolated);

	if #possibleisolatedfilter1 gt 0 then
		possibleisolatedfilter2 := FilterOutByGenus0(possibleisolatedfilter1,G0);
		return [*possibleisolatedfilter2*];
	else
		return [*possibleisolatedfilter1*];
	end if;
end intrinsic;